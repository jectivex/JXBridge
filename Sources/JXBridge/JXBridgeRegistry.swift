#if canImport(ObjectiveC)
import Foundation
#endif

/// Registry of bridged types.
public class JXBridgeRegistry {
    private var bridgesByGivenTypeName: [String: JXBridge] = [:]
    private var bridgesByActualTypeName: [String: JXBridge] = [:]
    private var namespacesByGivenTypeName: [String: String] = [:]
    private var requestedInvalidTypeNames: Set<String> = []

    /// The default namespace to which bridged types are added in JavaScript. Defaults to `jx`. Any type that is auto-registered or added without an explicit namespace uses this default.
    var defaultNamespace = "jx" {
        didSet {
            guard defaultNamespace == oldValue || bridgesByGivenTypeName.isEmpty else {
                fatalError("You cannot change JXBridgeRegistry.defaultNamespace once types have been registered")
            }
        }
    }

    /// The set of auto-registration behaviors for this registry.
    var autoRegistration: [JXBridgeAutoRegistration] = []

    /// Add a type bridge.
    public func add(_ bridge: JXBridge, namespace: String? = nil) {
        var preparedBridge = bridge
        preparedBridge.prepareLookupCaches()
        bridgesByGivenTypeName[bridge.typeName] = preparedBridge
        bridgesByActualTypeName[String(describing: bridge.type)] = preparedBridge
        namespacesByGivenTypeName[bridge.typeName] = namespace ?? defaultNamespace
        autoRegistration.forEach { $0.registering.didAdd(bridge: preparedBridge, to: self) }
    }

    /// Add a type bridge generated by the given `JXBridging` or `NSObject` type.
    public func add(for type: Any.Type, namespace: String? = nil) throws {
        if let bridgingType = type as? JXBridging.Type {
            add(forBridgingType: bridgingType, namespace: namespace)
        } else {
#if canImport(ObjectiveC)
            if let nsobjectType = type as? NSObject.Type {
                add(forObjectiveCType: nsobjectType, namespace: namespace)
            } else {
                throw JXBridgeErrors.cannotRegisterType(String(describing: type))
            }
#else
            throw JXBridgeErrors.cannotRegisterType(String(describing: type))
#endif
        }
    }

    /// Add a type bridge generated by a `JXBridging` type.
    public func add<T: JXBridging>(forBridgingType type: T.Type, namespace: String? = nil) {
        add(T.bridgeJX(), namespace: namespace)
    }

    /// Add a type bridge for a `JXBridging` instance, including property wrapper information.
    public func add<T: JXBridging>(for instance: T, namespace: String? = nil) {
        let bridge = T.bridgeJX()
        if bridge.includesInstanceInfo {
            add(bridge, namespace: namespace)
        } else {
            let builder = MirrorBuilder(Mirror(reflecting: instance), bridge: bridge)
            builder.addReflectedMembers()
            add(builder.bridge, namespace: namespace)
        }
    }

#if canImport(ObjectiveC)

    /// Add a type bridge for an ObjectiveC type using reflection.
    public func add<T: NSObject>(forObjectiveCType type: T.Type, namespace: String? = nil) {
        let builder = JXBridgeBuilder(type: type)
        builder.addObjectiveCPropertiesAndMethods()
        add(builder.bridge, namespace: namespace)
    }

#endif

    /// Whether a type bridge has been added for the given type name.
    ///
    /// - Parameters:
    ///   - typeName: Corresponds to the desired `JXBridge.typeName`, which may not be the same as the class/struct name.
    public func hasBridge(for typeName: String) -> Bool {
        return findBridge(for: typeName, autobridging: false) != nil
    }

    /// Return the type bridge for the given type name. If auto-registration is enabled, this may return a bridge even when `hasBridge` returns `false`.
    /// 
    /// - Parameters:
    ///   - typeName: Corresponds to the desired `JXBridge.typeName`, which may not be the same as the class/struct name.
    public func bridge(for typeName: String) throws -> JXBridge {
        guard let bridge = findBridge(for: typeName, autobridging: true) else {
            throw JXBridgeErrors.unknownType(typeName)
        }
        return bridge
    }

    private func findBridge(for typeName: String, autobridging: Bool) -> JXBridge? {
        if let bridge = bridgesByGivenTypeName[typeName] {
            return bridge
        }
        if autobridging, let bridge = addAutoBridge(for: typeName) {
            return bridge
        }
        return nil
    }

    /// Whether a type bridge has been added for the type of the given instance.
    public func hasBridge(for instance: Any) -> Bool {
        return hasBridge(for: type(of: instance))
    }

    /// Whether a type bridge has been added for the given type.
    public func hasBridge(for type: Any.Type) -> Bool {
        return findBridge(for: type, autobridging: false) != nil
    }

    /// Return the type bridge for the given type. If auto-registration is enabled, this may return a bridge even when `hasBridge` returns `false`.
    public func bridge(for instance: Any) throws -> JXBridge {
        let type = type(of: instance)
        let bridge = try bridge(for: type)
        guard !bridge.includesInstanceInfo && instance is JXBridging else {
            return bridge
        }

        let builder = MirrorBuilder(Mirror(reflecting: instance), bridge: bridge)
        builder.addReflectedMembers()
        add(builder.bridge, namespace: namespacesByGivenTypeName[bridge.typeName] ?? defaultNamespace)
        return try self.bridge(for: type)
    }

    /// Return the type bridge for the given type. If auto-registration is enabled, this may return a bridge even when `hasBridge` returns `false`.
    public func bridge(for type: Any.Type) throws -> JXBridge {
        guard let bridge = findBridge(for: type, autobridging: true) else {
            throw JXBridgeErrors.unknownType(String(describing: type))
        }
        return bridge
    }

    private func findBridge(for type: Any.Type, autobridging: Bool) -> JXBridge? {
        let typeName = String(describing: type)
        if let bridge = bridgesByActualTypeName[typeName] {
            return bridge
        }
        if autobridging, let bridge = addAutoBridge(for: type) {
            return bridge
        }
        return nil
    }

    private func addAutoBridge(for typeName: String) -> JXBridge? {
        for registration in autoRegistration {
            if registration.registering.addBridge(for: typeName, to: self) {
                return findBridge(for: typeName, autobridging: false)
            }
        }
        return nil
    }

    private func addAutoBridge(for type: Any.Type) -> JXBridge? {
        for registration in autoRegistration {
            if registration.registering.addBridge(for: type, to: self) {
                return findBridge(for: type, autobridging: false)
            }
        }
        return nil
    }
}
