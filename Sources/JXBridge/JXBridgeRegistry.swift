import Combine
#if canImport(ObjectiveC)
import Foundation
#endif

/// Registry of bridged types.
public class JXBridgeRegistry {
    private var bridgesByGivenTypeName: [QualifiedTypeName: JXBridge] = [:]
    private var bridgesByActualTypeName: [QualifiedTypeName: JXBridge] = [:]
    private var namespacesByActualTypeName: [String: String] = [:]
    private var requestedInvalidTypeNames: Set<String> = []
    
    private(set) var namespaces: Set<String> = []
    let didAddNamespaceSubject = PassthroughSubject<String, Never>()

    /// The default namespace to which bridged types are added in JavaScript. Defaults to `jx`. Any type that is added without an explicit namespace uses this default.
    public var defaultNamespace = "jx"
    
    /// The set of auto-registration behaviors for this registry.
    ///
    /// - Note: Auto-registration only applies to type names in the default namespace.
    public var autoRegistration: [JXBridgeAutoRegistration] = []
    // We rely on context.registry being accessed to initialize our SPI. Defaulting to no auto-registration
    // ensures the developer must access the registry before attempting to use any bridged types, either to
    // setup auto-registration or explicitly register
    
    public init() {
        namespaces.insert(defaultNamespace)
    }

    /// Add a type bridge.
    ///
    /// - Throws `JXBrigeErrors.namespaceViolation` if you attempt to register the same type under multiple namespaces.
    public func add(_ bridge: JXBridge, namespace: String? = nil) throws {
        let actualTypeName = String(describing: bridge.type)
        let assignedNamespace = namespace ?? defaultNamespace
        if let previousNamespace = namespacesByActualTypeName[actualTypeName], previousNamespace != assignedNamespace {
            throw JXBridgeErrors.namespaceViolation(actualTypeName, previousNamespace, assignedNamespace)
        }
            
        var preparedBridge = bridge
        preparedBridge.namespace = assignedNamespace
        preparedBridge.prepareLookupCaches()
        bridgesByGivenTypeName[QualifiedTypeName(typeName: bridge.typeName, namespace: assignedNamespace)] = preparedBridge
        bridgesByActualTypeName[QualifiedTypeName(typeName: actualTypeName, namespace: assignedNamespace)] = preparedBridge
        namespacesByActualTypeName[actualTypeName] = assignedNamespace
        
        let (inserted, _) = namespaces.insert(assignedNamespace)
        if inserted {
            didAddNamespaceSubject.send(assignedNamespace)
        }
    }

    /// Add a type bridge generated by a `JXBridging` type.
    public func add<T: JXBridging>(for type: T.Type, namespace: String? = nil) throws {
        try add(T.bridgeJX(), namespace: namespace)
    }

#if canImport(ObjectiveC)

    /// Add a type bridge for an ObjectiveC type using reflection.
    public func add<T: NSObject>(forObjectiveCType type: T.Type, namespace: String? = nil) throws {
        let builder = JXBridgeBuilder(type: type)
        builder.addObjectiveCPropertiesAndMethods()
        try add(builder.bridge, namespace: namespace)
    }

#endif

    /// Return the registered type bridge for the given type name.
    /// 
    /// - Parameters:
    ///   - typeName: Corresponds to the desired `JXBridge.typeName`, which may not be the same as the class/struct name.
    public func bridge(for typeName: String, namespace: String? = nil) -> JXBridge? {
        do {
            return try bridge(for: typeName, namespace: namespace ?? defaultNamespace, autobridging: false)
        } catch {
            // Call should not have been to throw when autobridging is false
            return nil
        }
    }

    func bridge(for typeName: String, namespace: String, autobridging: Bool) throws -> JXBridge? {
        let key = QualifiedTypeName(typeName: typeName, namespace: namespace)
        if let bridge = bridgesByGivenTypeName[key] {
            return bridge
        }
        if autobridging && namespace == defaultNamespace, let bridge = try addAutoBridge(for: typeName) {
            return bridge
        }
        return nil
    }

    func bridge(for instance: Any, autobridging: Bool) throws -> JXBridge? {
        let type = type(of: instance)
        return try bridge(for: type) ?? (autobridging ? addAutoBridge(for: instance) : nil)
    }

    /// Return the type bridge for the given type.
    public func bridge(for type: Any.Type) -> JXBridge? {
        let typeName = String(describing: type)
        guard let namespace = namespacesByActualTypeName[typeName] else {
            return nil
        }
        let key = QualifiedTypeName(typeName: typeName, namespace: namespace)
        return bridgesByActualTypeName[key]
    }

    private func addAutoBridge(for typeName: String) throws -> JXBridge? {
        for registration in autoRegistration {
            if try registration.policy.addBridge(for: typeName, to: self) {
                do {
                    return try bridge(for: typeName, namespace: defaultNamespace, autobridging: false)
                } catch {
                    // Call should not have been able to throw when autobridging is false
                    return nil
                }
            }
        }
        return nil
    }
    
    private func addAutoBridge(for instance: Any) throws -> JXBridge? {
        for registration in autoRegistration {
            if try registration.policy.addBridge(for: instance, to: self) {
                return bridge(for: type(of: instance))
            }
        }
        return nil
    }
}
