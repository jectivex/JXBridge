import Foundation

/// Registry of bridged types.
public class JXBridgeRegistry {
    private var bridgesByGivenTypeName: [String: JXBridge] = [:]
    private var bridgesByActualTypeName: [String: JXBridge] = [:]
    private var namespacesByGivenTypeName: [String: String] = [:]
    private var requestedInvalidTypeNames: Set<String> = []

    /// The default namespace to which bridged types are added in JavaScript. Defaults to `jx`. Any type that is auto-registered or added without an explicit namespace uses this default.
    var defaultNamespace = "jx" {
        didSet {
            guard defaultNamespace == oldValue || bridgesByGivenTypeName.isEmpty else {
                fatalError("You cannot change JXBridgeRegistry.defaultNamespace once types have been registered")
            }
        }
    }

    /// Add a type bridge.
    public func add(_ bridge: JXBridge, namespace: String? = nil) {
        var preparedBridge = bridge
        preparedBridge.prepareLookupCaches()
        bridgesByGivenTypeName[bridge.typeName] = preparedBridge
        bridgesByActualTypeName[String(describing: bridge.type)] = preparedBridge
        namespacesByGivenTypeName[bridge.typeName] = namespace ?? defaultNamespace
    }

    /// Add a type bridge generated by a `JXBridging` type.
    public func add<T: JXBridging>(for type: T.Type, namespace: String? = nil) {
        add(T.bridgeJX(), namespace: namespace)
    }

    /// Add a type bridge for a `JXBridging` instance, including property wrapper information.
    public func add<T: JXBridging>(for instance: T, namespace: String? = nil) {
        let bridge = T.bridgeJX()
        if bridge.includesInstanceInfo {
            add(bridge, namespace: namespace)
        } else {
            let builder = MirrorBuilder(Mirror(reflecting: instance), bridge: bridge)
            builder.addReflectedMembers()
            add(builder.bridge, namespace: namespace)
        }
    }

#if canImport(ObjectiveC)

    /// Whether to auto-register ObjectiveC types, allowing JavaScript to use any ObjectiveC type without registration.
    var isObjectiveCAutoBridgingEnabled = false

    /// Add a type bridge for an ObjectiveC type using reflection.
    public func add<T: NSObject>(forObjectiveCType type: T.Type, namespace: String? = nil) {
        let builder = JXBridgeBuilder(type: type)
        builder.addObjectiveCPropertiesAndMethods()
        add(builder.bridge, namespace: namespace)
    }

#endif

    /// Whether a type bridge has been added for the given type name.
    ///
    /// - Parameters:
    ///   - typeName: Corresponds to the desired `JXBridge.typeName`, which may not be the same as the class/struct name.
    public func hasBridge(for typeName: String) -> Bool {
        return findBridge(for: typeName, autobridging: false) != nil
    }

    /// Return the type bridge for the given type name. If auto-registration is enabled, this may return a bridge even when `hasBridge` returns `false`.
    /// 
    /// - Parameters:
    ///   - typeName: Corresponds to the desired `JXBridge.typeName`, which may not be the same as the class/struct name.
    public func bridge(for typeName: String) throws -> JXBridge {
        guard let bridge = findBridge(for: typeName, autobridging: true) else {
            throw JXBridgeErrors.unknownType(typeName)
        }
        return bridge
    }

    private func findBridge(for typeName: String, autobridging: Bool) -> JXBridge? {
        if let bridge = bridgesByGivenTypeName[typeName] {
            return bridge
        }
        if autobridging, let bridge = addAutoBridge(for: typeName) {
            return bridge
        }
        return nil
    }

    /// Whether a type bridge has been added for the type of the given instance.
    public func hasBridge(for instance: Any) -> Bool {
        return hasBridge(for: type(of: instance))
    }

    /// Whether a type bridge has been added for the given type.
    public func hasBridge(for type: Any.Type) -> Bool {
        return findBridge(for: type, autobridging: false) != nil
    }

    /// Return the type bridge for the given type. If auto-registration is enabled, this may return a bridge even when `hasBridge` returns `false`.
    public func bridge(for instance: Any) throws -> JXBridge {
        let type = type(of: instance)
        let bridge = try bridge(for: type)
        guard !bridge.includesInstanceInfo && instance is JXBridging else {
            return bridge
        }

        let builder = MirrorBuilder(Mirror(reflecting: instance), bridge: bridge)
        builder.addReflectedMembers()
        add(builder.bridge, namespace: namespacesByGivenTypeName[bridge.typeName] ?? defaultNamespace)
        return try self.bridge(for: type)
    }

    /// Return the type bridge for the given type. If auto-registration is enabled, this may return a bridge even when `hasBridge` returns `false`.
    public func bridge(for type: Any.Type) throws -> JXBridge {
        guard let bridge = findBridge(for: type, autobridging: true) else {
            throw JXBridgeErrors.unknownType(String(describing: type))
        }
        return bridge
    }

    private func findBridge(for type: Any.Type, autobridging: Bool) -> JXBridge? {
        let typeName = String(describing: type)
        if let bridge = bridgesByActualTypeName[typeName] {
            return bridge
        }
        if autobridging, let bridge = addAutoBridge(for: type) {
            return bridge
        }
        return nil
    }

    private func addAutoBridge(for typeName: String) -> JXBridge? {
#if canImport(ObjectiveC)
        guard isObjectiveCAutoBridgingEnabled, !requestedInvalidTypeNames.contains(typeName) else {
            return nil
        }
        guard let type = NSClassFromString(typeName), type.isSubclass(of: NSObject.self) else {
            requestedInvalidTypeNames.insert(typeName)
            return nil
        }
        let builder = ObjectiveCBuilder(type, bridge: JXBridge(type: type))
        builder.addObjectiveCPropertiesAndMethods()
        var bridge = builder.bridge
        bridge.prepareLookupCaches()
        add(bridge)
        return bridge
#else
        return nil
#endif
    }

    private func addAutoBridge(for type: Any.Type) -> JXBridge? {
#if canImport(ObjectiveC)
        guard isObjectiveCAutoBridgingEnabled else {
            return nil
        }
        guard let cls = type as? AnyClass, cls.isSubclass(of: NSObject.self) else {
            return nil
        }
        let builder = ObjectiveCBuilder(cls, bridge: JXBridge(type: type))
        builder.addObjectiveCPropertiesAndMethods()
        var bridge = builder.bridge
        bridge.prepareLookupCaches()
        add(bridge)
        return bridge
#else
        return nil
#endif
    }
}
