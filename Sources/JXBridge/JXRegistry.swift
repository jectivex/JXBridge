#if canImport(ObjectiveC)
import Foundation
#endif
import JXKit

/// Registry of bridged types.
public final class JXRegistry {
    private var bridgesByGivenTypeName: [TypeNameKey: JXBridge] = [:]
    private var bridgesByActualTypeName: [String: JXBridge] = [:]
    private(set) var modulesByNamespace: [JXNamespace: [JXModule]] = [:] // 0 or 1 module per known namespace. Internal for testing
    private var moduleScriptsByNamespace: [JXNamespace: [JSModuleScript]] = [:]
    private var unnamespacedModules: [JXModule] = []
    
    // Allow any context using this registry to listen for additions that require JS generation
    let listeners = RegistryListeners()
    var namespaces: AnyCollection<JXNamespace> {
        return AnyCollection(modulesByNamespace.keys)
    }
    var modules: AnyCollection<JXModule> {
        return AnyCollection(modulesByNamespace.values.flatMap({ $0 }) + unnamespacedModules)
    }
    func bridges(in namespace: JXNamespace) -> AnyCollection<JXBridge> {
        return AnyCollection(bridgesByGivenTypeName.compactMap { $0.key.namespace == namespace ? $0.value : nil })
    }
    func moduleScripts(in namespace: JXNamespace) -> AnyCollection<JSModuleScript> {
        return AnyCollection(moduleScriptsByNamespace[namespace] ?? [])
    }

    public init() {
        modulesByNamespace[.default] = []
    }
    
    /// Register a module for use in JavaScript. Has no effect if the module has a namespace and has already been registered.
    @discardableResult public func register(_ module: JXModule) throws -> Bool {
        guard module.namespace != .none else {
            try module.register(with: self)
            unnamespacedModules.append(module)
            try listeners.didRegisterModule(module)
            return true
        }
        
        let existingModules = modulesByNamespace[module.namespace]
        guard (existingModules?.count ?? 0) == 0 else {
            return false
        }
        modulesByNamespace[module.namespace] = [module] // Assign before initializing to avoid recursion on circular dependencies
        if existingModules == nil {
            try listeners.didAddNamespace(module.namespace)
        }
        do {
            try module.register(with: self)
        } catch {
            // Remove bad module
            modulesByNamespace[module.namespace] = []
            throw error
        }
        try listeners.didRegisterModule(module)
        return true
    }
    
    /// Return the module registered under the given namespace, or nil if none has been registered. Modules registered under ``JXNamespace/none`` are not returned.
    public func module(for namespace: JXNamespace) -> JXModule? {
        return modulesByNamespace[namespace]?.first
    }

    /// Register a bridge for use in JavaScript.
    ///
    /// - Throws An error if you attempt to use an invalid namespace or register the same type under multiple namespaces.
    /// - Note: This method does **not** automatically register any superclass bridge.
    public func register(_ bridge: JXBridge) throws {
        let actualTypeName = String(reflecting: bridge.type)
        if let previousNamespace = bridgesByActualTypeName[actualTypeName]?.namespace, previousNamespace != bridge.namespace {
            throw JXError(message: "Attempt to register type '\(String(describing: bridge.type))' under second namespace '\(bridge.namespace)'. That type is already registered under namespace '\(previousNamespace)'")
        }
            
        var preparedBridge = bridge
        preparedBridge.prepareLookupCaches()
        bridgesByGivenTypeName[TypeNameKey(typeName: preparedBridge.typeName, namespace: preparedBridge.namespace)] = preparedBridge
        bridgesByActualTypeName[actualTypeName] = preparedBridge
        
        if preparedBridge.namespace == .none {
            try listeners.didRegisterUnnamespacedBridge(preparedBridge)
        } else if modulesByNamespace[preparedBridge.namespace] == nil {
            modulesByNamespace[preparedBridge.namespace] = []
            try listeners.didAddNamespace(preparedBridge.namespace)
        }
    }
    
    /// Register a bridge for use in JavaScript. Use this block-based method for trailing closure syntax:
    ///
    ///     registry.register {
    ///         JXBridgeBuilder(...)
    ///             .var.xxx { ... }
    ///             .bridge
    ///     }
    ///
    /// - Throws An error if you attempt to use an invalid namespace or register the same type under multiple namespaces.
    public func register(_ bridge: () -> JXBridge) throws {
        try register(bridge())
    }

    /// Register a bridge generated by a ``JXStaticBridging`` type for use in JavaScript.
    ///
    /// - Parameters:
    ///   - namespace: Override the generated bridge's namespace. This applies only to the bridge for the given type, not to any superclass bridge that may also be generated.
    /// - Throws An error if you attempt to use an invalid namespace or register the same type under multiple namespaces.
    /// - Note: This method automatically registers the superclass bridge if it also conforms to ``JXStaticBridging``.
    @discardableResult public func registerBridge<T: JXStaticBridging>(for type: T.Type, namespace: JXNamespace? = nil) throws -> JXBridge {
        var bridge = try type.jxBridge()
        if let bridgingSuperclass = bridge.superclass as? JXStaticBridging.Type, self.bridge(for: bridgingSuperclass) == nil {
            try registerBridge(for: bridgingSuperclass)
        }
        if let namespace {
            bridge.namespace = namespace
        }
        try register(bridge)
        return bridge
    }
    
    /// Register a bridge generated by a ``JXBridging`` instance for use in JavaScript.
    ///
    /// - Parameters:
    ///   - namespace: Override the generated bridge's namespace. This applies only to the bridge for the given type, not to any superclass bridge that may also be generated.
    /// - Throws An error if you attempt to use an invalid namespace or register the same type under multiple namespaces.
    /// - Note: This method automatically registers the superclass bridge if it also conforms to ``JXStaticBridging`` or ``JXBridging``.
    @discardableResult public func registerBridge<T: JXBridging>(for instance: T, namespace: JXNamespace? = nil) throws -> JXBridge {
        let mirror = Mirror(reflecting: instance)
        return try registerBridge(for: type(of: instance), mirror: mirror, namespace: namespace)
    }
    
    @discardableResult private func registerBridge<T: JXBridging>(for type: T.Type, mirror: Mirror, namespace: JXNamespace?) throws -> JXBridge {
        var bridge = try type.jxBridge(mirror: mirror)
        // Deal with the following scenario:
        // - Base class implements jxBridge(mirror:)
        // - Subclass does not implement the method because it wants to rely on the default of reflecting on property wrappers.
        // - So when we call the method on the subclass, we get the base class bridge.
        // In this case we want to disregard the returend bridge and use default bridge in its place.
        // NOTE: Unfortunately we can only detect this error if the base class constructs its JXBridgeBuilder with its explicit type. If it uses Self, then the bridge will get the subclass type, and there is no way to detect the error.
        if (String(reflecting: bridge.type) != String(reflecting: type)) {
            bridge = JXBridgeBuilder(type: type, namespace: type.jxNamespace).reflect(mirror).bridge
        }
        if let superclass = bridge.superclass, self.bridge(for: superclass) == nil {
            if let bridgingSuperclass = superclass as? JXStaticBridging.Type {
                try registerBridge(for: bridgingSuperclass)
            } else if let bridgingSuperclass = superclass as? JXBridging.Type, let superclassMirror = mirror.superclassMirror {
                try registerBridge(for: bridgingSuperclass, mirror: superclassMirror, namespace: nil)
            }
        }
        if let namespace {
            bridge.namespace = namespace
        }
        try register(bridge)
        return bridge
    }

#if canImport(ObjectiveC)
    
    /// - Seealso: ``JXBridgeBuilder/reflectObjectiveCMembers(prefixes:)``
    public var objectiveCMemberPrefixes: [String] = []

    /// Register a bridge populated using ObjectiveC reflection for use in JavaScript.
    ///
    /// - Parameters:
    ///   - namespace: The namespace under which to add the type.
    /// - Throws An error if you attempt to use an invalid namespace or register the same type under multiple namespaces.
    /// - Note: This method automatically registers any superclass bridge under the same namespace.
    @discardableResult public func registerBridge<T: NSObject>(forObjectiveC type: T.Type, namespace: JXNamespace? = nil) throws -> JXBridge {
        // Still allow customization
        if let bridgingType = type as? JXStaticBridging.Type {
            return try registerBridge(for: bridgingType, namespace: namespace)
        }
        
        // For fully ObjectiveC types, use proxy bridging
        let builder = JXBridgeBuilder(type: type, namespace: namespace ?? .default)
        builder.reflectObjectiveCMembers(prefixes: objectiveCMemberPrefixes)
        let bridge = builder.bridge
        if let nsobjectSuperclassType = bridge.superclass as? NSObject.Type {
            try registerBridge(forObjectiveC: nsobjectSuperclassType, namespace: namespace)
        }
        try register(bridge)
        return builder.bridge
    }

#endif
    
    /// Register a JavaScript module resource to integrate into the given namespace. The JavaScript will be run and its exports will be added to the namespace.
    public func registerModuleScript(resource: String, namespace: JXNamespace) throws {
        try registerModuleScript(JSModuleScript(source: .resource(resource), namespace: namespace))
    }
    
    /// Register JavaScript module code to integrate into the given namespace. The JavaScript will be run and its exports will be added to the namespace.
    public func registerModuleScript(_ script: String, namespace: JXNamespace) throws {
        try registerModuleScript(JSModuleScript(source: .js(script), namespace: namespace))
    }
    
    private func registerModuleScript(_ script: JSModuleScript) throws {
        if var existingScripts = moduleScriptsByNamespace[script.namespace] {
            existingScripts.append(script)
            moduleScriptsByNamespace[script.namespace] = existingScripts
            try listeners.didRegisterModuleScript(script)
            return
        }
        
        if script.namespace != .none {
            if !modulesByNamespace.keys.contains(script.namespace) {
                modulesByNamespace[script.namespace] = []
                try listeners.didAddNamespace(script.namespace)
            }
        }
        moduleScriptsByNamespace[script.namespace] = [script]
        try listeners.didRegisterModuleScript(script)
    }

    /// Return the registered bridge for the given type name, or nil if none has been registered.
    /// 
    /// - Parameters:
    ///   - typeName: Corresponds to the desired `JXBridge.typeName`, which may not be the same as the class/struct name.
    ///   - namespace: The type's namespace.
    public func bridge(for typeName: String, namespace: JXNamespace = .default) -> JXBridge? {
        do {
            return try bridge(for: typeName, namespace: namespace, definingIn: nil)
        } catch {
            // Call should not throw when autobridging is false
            return nil
        }
    }

    func bridge(for typeName: String, namespace: JXNamespace, definingIn context: JXContext?) throws -> JXBridge? {
        let key = TypeNameKey(typeName: typeName, namespace: namespace)
        if let bridge = bridgesByGivenTypeName[key] {
            return bridge
        }
        if let context, let bridge = try define(for: typeName, namespace: namespace, in: context) {
            return bridge
        }
        return nil
    }

    /// Return the registered bridge for the given type, or nil if none has been registered.
    public func bridge(for type: Any.Type) -> JXBridge? {
        let actualTypeName = String(reflecting: type)
        return bridgesByActualTypeName[actualTypeName]
    }
    
    /// Return the registered bridge for the type of the given instance, or nil if none has been registered.
    public func bridge(for instance: Any) -> JXBridge? {
        do {
            return try bridge(for: instance, definingIn: nil)
        } catch {
            // Call should not throw when autobridging is false
            return nil
        }
    }
    
    func bridge(for instance: Any, definingIn context: JXContext?) throws -> JXBridge? {
        let type = type(of: instance)
        if let bridge = bridge(for: type) {
            return bridge
        }
        guard let context else {
            return nil
        }
        return try define(for: instance, in: context)
    }

    private func define(for typeName: String, namespace: JXNamespace, in context: JXContext) throws -> JXBridge? {
        for module in (modulesByNamespace[namespace] ?? []) + unnamespacedModules {
            if try module.define(symbol: typeName, namespace: namespace, in: context) {
                return try bridge(for: typeName, namespace: namespace, definingIn: nil)
            }
        }
        return nil
    }
    
    private func define(for instance: Any, in context: JXContext) throws -> JXBridge? {
        for module in modulesByNamespace.values.flatMap({ $0 }) + unnamespacedModules {
            if try module.define(for: instance, in: context) {
                return try bridge(for: instance, definingIn: nil)
            }
        }
        return nil
    }
}

private struct TypeNameKey: Hashable {
    let typeName: String
    let namespace: JXNamespace
}
