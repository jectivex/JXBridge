#if canImport(ObjectiveC)
import Foundation
#endif

/// Registry of bridged types.
public final class JXRegistry {
    private var bridgesByGivenTypeName: [TypeNameKey: JXBridge] = [:]
    private var bridgesByActualTypeName: [String: JXBridge] = [:]
    private(set) var modulesByNamespace: [JXNamespace: [JXModule]] = [:] // 0 or 1 module per known namespace. Internal for testing
    private var unnamespacedModules: [JXModule] = []
    
    // Allow any context using this registry to listen for additions that require JS generation
    let listeners = RegistryListeners()
    var namespaces: any Sequence<JXNamespace> {
        return modulesByNamespace.keys
    }
    var modules: any Sequence<JXModule> {
        return modulesByNamespace.values.flatMap({ $0 }) + unnamespacedModules
    }
    var unnamespacedBridges: any Sequence<JXBridge> {
        return bridgesByActualTypeName.values.filter { $0.namespace == .none }
    }

    public init() {
        modulesByNamespace[.default] = []
    }
    
    /// Register a module for use in JavaScript. Has no effect if the module has a namespace and has already been registered.
    @discardableResult public func register(_ module: JXModule) throws -> Bool {
        guard module.namespace != .none else {
            try module.register(with: self)
            unnamespacedModules.append(module)
            try listeners.didRegisterModule(module)
            return true
        }
        
        let existingModules = modulesByNamespace[module.namespace]
        guard (existingModules?.count ?? 0) == 0 else {
            return false
        }
        modulesByNamespace[module.namespace] = [module] // Assign before initializing to avoid recursion on circular dependencies
        if existingModules == nil {
            try listeners.didAddNamespace(module.namespace)
        }
        do {
            try module.register(with: self)
        } catch {
            // Remove bad module
            modulesByNamespace[module.namespace] = []
            throw error
        }
        try listeners.didRegisterModule(module)
        return true
    }

    /// Register a bridge for use in JavaScript.
    ///
    /// - Throws `JXBrigeErrors.namespaceViolation` if you attempt to use an invalid namespace or register the same type under multiple namespaces.
    /// - Note: This method does **not** automatically register any superclass bridge.
    public func register(_ bridge: JXBridge) throws {
        let actualTypeName = String(reflecting: bridge.type)
        if let previousNamespace = bridgesByActualTypeName[actualTypeName]?.namespace, previousNamespace != bridge.namespace {
            throw JXBridgeErrors.namespaceViolation(actualTypeName, previousNamespace.value)
        }
            
        var preparedBridge = bridge
        preparedBridge.prepareLookupCaches()
        bridgesByGivenTypeName[TypeNameKey(typeName: preparedBridge.typeName, namespace: preparedBridge.namespace)] = preparedBridge
        bridgesByActualTypeName[actualTypeName] = preparedBridge
        
        if preparedBridge.namespace == .none {
            try listeners.didRegisterUnnamespacedBridge(preparedBridge)
        } else if modulesByNamespace[preparedBridge.namespace] == nil {
            modulesByNamespace[preparedBridge.namespace] = []
            try listeners.didAddNamespace(preparedBridge.namespace)
        }
    }
    
    /// Register a bridge for use in JavaScript. Use this block-based method for trailing closure syntax:
    ///
    ///     registry.register {
    ///         JXBridgeBuilder(...)
    ///             .var.xxx { ... }
    ///             .bridge
    ///     }
    ///
    /// - Throws `JXBrigeErrors.namespaceViolation` if you attempt to use an invalid namespace or register the same type under multiple namespaces.
    public func register(_ bridge: () -> JXBridge) throws {
        try register(bridge())
    }

    /// Register a bridge generated by a `JXStaticBridging` type for use in JavaScript.
    ///
    /// - Parameters:
    ///   - namespace: Override the generated bridge's namespace. This applies only to the bridge for the given type, not to any superclass bridge that may also be generated.
    /// - Throws `JXBrigeErrors.namespaceViolation` if you attempt to use an invalid namespace or register the same type under multiple namespaces.
    /// - Note: This method automatically registers the superclass bridge if it also conforms to `JXStaticBridging`.
    @discardableResult public func registerBridge<T: JXStaticBridging>(for type: T.Type, namespace: JXNamespace? = nil) throws -> JXBridge {
        var bridge = try type.jxBridge()
        if let bridgingSuperclass = bridge.superclass as? JXStaticBridging.Type, self.bridge(for: bridgingSuperclass) == nil {
            try registerBridge(for: bridgingSuperclass)
        }
        if let namespace {
            bridge.namespace = namespace
        }
        try register(bridge)
        return bridge
    }
    
    /// Register a bridge generated by a `JXBridging` instance for use in JavaScript.
    ///
    /// - Parameters:
    ///   - namespace: Override the generated bridge's namespace. This applies only to the bridge for the given type, not to any superclass bridge that may also be generated.
    /// - Throws `JXBrigeErrors.namespaceViolation` if you attempt to use an invalid namespace or register the same type under multiple namespaces.
    /// - Note: This method automatically registers the superclass bridge if it also conforms to `JXStaticBridging` or `JXBridging`.
    @discardableResult public func registerBridge<T: JXBridging>(for instance: T, namespace: JXNamespace? = nil) throws -> JXBridge {
        let mirror = Mirror(reflecting: instance)
        return try registerBridge(for: type(of: instance), mirror: mirror, namespace: namespace)
    }
    
    @discardableResult private func registerBridge<T: JXBridging>(for type: T.Type, mirror: Mirror, namespace: JXNamespace?) throws -> JXBridge {
        var bridge = try type.jxBridge(mirror: mirror)
        // Deal with the following scenario:
        // - Base class implements jxBridge(mirror:)
        // - Subclass does not implement the method because it wants to rely on the default of reflecting on property wrappers.
        // - So when we call the method on the subclass, we get the base class bridge.
        // In this case we want to disregard the returend bridge and use default bridge in its place.
        // NOTE: Unfortunately we can only detect this error if the base class constructs its JXBridgeBuilder with its explicit type. If it uses Self, then the bridge will get the subclass type, and there is no way to detect the error.
        if (String(reflecting: bridge.type) != String(reflecting: type)) {
            bridge = JXBridgeBuilder(type: type, namespace: type.jxNamespace).reflect(mirror).bridge
        }
        if let superclass = bridge.superclass, self.bridge(for: superclass) == nil {
            if let bridgingSuperclass = superclass as? JXStaticBridging.Type {
                try registerBridge(for: bridgingSuperclass)
            } else if let bridgingSuperclass = superclass as? JXBridging.Type, let superclassMirror = mirror.superclassMirror {
                try registerBridge(for: bridgingSuperclass, mirror: superclassMirror, namespace: nil)
            }
        }
        if let namespace {
            bridge.namespace = namespace
        }
        try register(bridge)
        return bridge
    }

#if canImport(ObjectiveC)

    /// Register a bridge populated using ObjectiveC reflection for use in JavaScript.
    ///
    /// - Parameters:
    ///   - namespace: The namespace under which to add the type.
    /// - Note: This method automatically registers any superclass bridge under the same namespace.
    /// - Throws `JXBrigeErrors.namespaceViolation` if you attempt to use an invalid namespace or register the same type under multiple namespaces.
    @discardableResult public func registerBridge<T: NSObject>(forObjectiveC type: T.Type, namespace: JXNamespace = .default) throws -> JXBridge {
        let builder = JXBridgeBuilder(type: type, namespace: namespace)
        builder.reflectObjectiveCMembers()
        let bridge = builder.bridge
        if let bridgingSuperclassType = bridge.superclass as? JXStaticBridging.Type {
            try registerBridge(for: bridgingSuperclassType, namespace: namespace)
        } else if let nsobjectSuperclassType = bridge.superclass as? NSObject.Type {
            try registerBridge(forObjectiveC: nsobjectSuperclassType, namespace: namespace)
        }
        try register(bridge)
        return builder.bridge
    }

#endif

    /// Return the registered bridge for the given type name, or nil if none has been registered.
    /// 
    /// - Parameters:
    ///   - typeName: Corresponds to the desired `JXBridge.typeName`, which may not be the same as the class/struct name.
    ///   - namespace: The type's namespace.
    public func bridge(for typeName: String, namespace: JXNamespace = .default) -> JXBridge? {
        do {
            return try bridge(for: typeName, namespace: namespace, autobridging: false)
        } catch {
            // Call should not have been to throw when autobridging is false
            return nil
        }
    }

    func bridge(for typeName: String, namespace: JXNamespace, autobridging: Bool) throws -> JXBridge? {
        let key = TypeNameKey(typeName: typeName, namespace: namespace)
        if let bridge = bridgesByGivenTypeName[key] {
            return bridge
        }
        if autobridging, let bridge = try addAutoBridge(for: typeName, namespace: namespace) {
            return bridge
        }
        return nil
    }

    /// Return the registered bridge for the given type, or nil if none has been registered.
    public func bridge(for type: Any.Type) -> JXBridge? {
        let actualTypeName = String(reflecting: type)
        return bridgesByActualTypeName[actualTypeName]
    }
    
    /// Return the registered bridge for the type of the given instance, or nil if none has been registered.
    public func bridge(for instance: Any) -> JXBridge? {
        do {
            return try bridge(for: instance, autobridging: false)
        } catch {
            // Call should not have been to throw when autobridging is false
            return nil
        }
    }
    
    func bridge(for instance: Any, autobridging: Bool) throws -> JXBridge? {
        let type = type(of: instance)
        return try bridge(for: type) ?? (autobridging ? addAutoBridge(for: instance) : nil)
    }

    private func addAutoBridge(for typeName: String, namespace: JXNamespace) throws -> JXBridge? {
        for module in (modulesByNamespace[namespace] ?? []) + unnamespacedModules {
            if try module.registerBridge(for: typeName, namespace: namespace, in: self) {
                return try bridge(for: typeName, namespace: namespace, autobridging: false)
            }
        }
        return nil
    }
    
    private func addAutoBridge(for instance: Any) throws -> JXBridge? {
        for module in modulesByNamespace.values.flatMap({ $0 }) + unnamespacedModules {
            if try module.registerBridge(for: instance, in: self) {
                return try bridge(for: instance, autobridging: false)
            }
        }
        return nil
    }
}

private struct TypeNameKey: Hashable {
    let typeName: String
    let namespace: JXNamespace
}
