import Combine
#if canImport(ObjectiveC)
import Foundation
#endif

// TODO: Current namespace model is very loose: we allow multiple modes and other bridge additions per namespace. Be more strict?

/// Registry of bridged types.
public class JXRegistry {
    private var bridgesByGivenTypeName: [TypeNameKey: JXBridge] = [:]
    private var bridgesByActualTypeName: [String: JXBridge] = [:]
    private(set) var modulesByNamespace: [String: [JXModule]] = [:]
    let didAddNamespaceSubject = PassthroughSubject<String, Never>()

    /// The default namespace to which bridged types are added in JavaScript: `jx`.
    public static let defaultNamespace = "jx"
    
    public init() {
        modulesByNamespace[Self.defaultNamespace] = []
    }
    
    /// Register a module for use in JavaScript. Has no effect if the module has already been registered under its set namespace.
    ///
    /// - Parameters:
    ///   - namespace: The namespace under which to add the module. If nil or excluded, defaults to the module's set namespace.
    ///
    @discardableResult public func add(_ module: JXModule, namespace: String? = nil) throws -> Bool {
        let assignedNamespace = namespace ?? module.namespace
        let existingModules = modulesByNamespace[assignedNamespace]
        var modules = existingModules ?? []
        if modules.contains(where: { module.isEquivalent(to: $0) }) {
            return false
        }
        
        var preparedModule = module
        preparedModule.namespace = assignedNamespace
        modules.append(preparedModule)
        modulesByNamespace[assignedNamespace] = modules // Assign before initializing to avoid recursion
        if existingModules == nil {
            didAddNamespaceSubject.send(assignedNamespace)
        }
        do {
            try module.initialize(registry: self)
        } catch {
            // Remove bad module. Initialization may have added other modules, so re-fetch
            if var modules = modulesByNamespace[assignedNamespace] {
                modules.removeAll(where: { module.isEquivalent(to: $0) })
                modulesByNamespace[assignedNamespace] = modules
            }
            throw error
        }
        return true
    }

    /// Register a bridge for use in JavaScript.
    ///
    /// - Parameters:
    ///   - namespace: The namespace under which to add the type. If nil or excluded, defaults to first any namespace set on the bridge, then the default namespace.
    /// - Throws `JXBrigeErrors.namespaceViolation` if you attempt to register the same type under multiple namespaces.
    @discardableResult public func add(_ bridge: JXBridge, namespace: String? = nil) throws -> JXBridge {
        let actualTypeName = String(reflecting: bridge.type)
        let assignedNamespace = namespace ?? bridge.namespace ?? Self.defaultNamespace
        if let previousNamespace = bridgesByActualTypeName[actualTypeName]?.namespace, previousNamespace != assignedNamespace {
            throw JXBridgeErrors.namespaceViolation(actualTypeName, previousNamespace, assignedNamespace)
        }
            
        var preparedBridge = bridge
        preparedBridge.namespace = assignedNamespace
        preparedBridge.prepareLookupCaches()
        bridgesByGivenTypeName[TypeNameKey(typeName: bridge.typeName, namespace: assignedNamespace)] = preparedBridge
        bridgesByActualTypeName[actualTypeName] = preparedBridge
        
        if modulesByNamespace[assignedNamespace] == nil {
            modulesByNamespace[assignedNamespace] = []
            didAddNamespaceSubject.send(assignedNamespace)
        }
        return preparedBridge
    }

    /// Register a bridge generated by a `JXBridging` type for use in JavaScript.
    ///
    /// - Parameters:
    ///   - namespace: The namespace under which to add the type. If nil or excluded, defaults to first any namespace set on the bridge, then the default namespace.
    /// - Throws `JXBrigeErrors.namespaceViolation` if you attempt to register the same type under multiple namespaces.
    @discardableResult public func add<T: JXBridging>(for type: T.Type, namespace: String? = nil) throws -> JXBridge {
        return try add(T.bridgeJX(), namespace: namespace)
    }

#if canImport(ObjectiveC)

    /// Register a bridge populated using ObjectiveC reflection for use in JavaScript.
    ///
    /// - Parameters:
    ///   - namespace: The namespace under which to add the type. If nil, the default namespace.
    /// - Throws `JXBrigeErrors.namespaceViolation` if you attempt to register the same type under multiple namespaces.
    @discardableResult public func add<T: NSObject>(forObjectiveCType type: T.Type, namespace: String? = nil) throws -> JXBridge {
        let builder = JXBridgeBuilder(type: type)
        builder.addObjectiveCPropertiesAndMethods()
        return try add(builder.bridge, namespace: namespace)
    }

#endif

    /// Return the registered bridge for the given type name, or nil if none has been registered.
    /// 
    /// - Parameters:
    ///   - typeName: Corresponds to the desired `JXBridge.typeName`, which may not be the same as the class/struct name.
    ///   - namespace: The type's namespace, or nil to search the default namespace.
    public func bridge(for typeName: String, namespace: String? = nil) -> JXBridge? {
        do {
            return try bridge(for: typeName, namespace: namespace ?? Self.defaultNamespace, autobridging: false)
        } catch {
            // Call should not have been to throw when autobridging is false
            return nil
        }
    }

    func bridge(for typeName: String, namespace: String, autobridging: Bool) throws -> JXBridge? {
        let key = TypeNameKey(typeName: typeName, namespace: namespace)
        if let bridge = bridgesByGivenTypeName[key] {
            return bridge
        }
        if autobridging, let bridge = try addAutoBridge(for: typeName, namespace: namespace) {
            return bridge
        }
        return nil
    }

    func bridge(for instance: Any, autobridging: Bool) throws -> JXBridge? {
        let type = type(of: instance)
        return try bridge(for: type) ?? (autobridging ? addAutoBridge(for: instance) : nil)
    }

    /// Return the registered bridge for the given type, or nil if none has been registered.
    public func bridge(for type: Any.Type) -> JXBridge? {
        let actualTypeName = String(reflecting: type)
        return bridgesByActualTypeName[actualTypeName]
    }

    private func addAutoBridge(for typeName: String, namespace: String) throws -> JXBridge? {
        guard let modules = modulesByNamespace[namespace] else {
            return nil
        }
        for module in modules {
            if try module.addBridge(for: typeName, to: self) {
                return bridge(for: typeName, namespace: namespace)
            }
        }
        return nil
    }
    
    private func addAutoBridge(for instance: Any) throws -> JXBridge? {
        for module in modulesByNamespace.values.flatMap({ $0 }) {
            if try module.addBridge(for: instance, to: self) {
                return try bridge(for: instance, autobridging: false)
            }
        }
        return nil
    }
}
